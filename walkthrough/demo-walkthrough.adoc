= Serverless Demo 
:experimental:
:imagesdir: images
:toc:
:toclevels: 4

[IMPORTANT]
.On necessary operators
====
See link:demo-setup.adoc[] for information on operators and other prerequisites that must be installed for the demo to run properly.
====

== Payment Service on CRC 

In this section well show a payment service that is running to poll the kafka 

=== Setup Code Ready Containers 

. Download Code ready containers
. Unzip and move the binary to a location in your path
. Save the pull secret to a location in your home directory
. Configure the crc as follows:
+
----
crc config set cpus 8
crc config set memory 10486
crc config set pull-secret-file <PATH_TO_PULL_SECRET>
----
+
. Run `crc setup`
. Run `crc start` and once started record the login information presented

=== Optional: Show UI Installation of necessary operators

For this section you will need two windows: a command line shell and the web browser (for the console)

. From the console, run `crc console` which should show the OpenShift console in the running CRC instance
** NOTE:  Make sure you have the kube admin login password handy
. Go to _Operators > Operator Hub_
. Search for Knative and select the OpenShift Serverless Operator
. Select install (for all projects)
. OPTIONAL: Search for Kafka and select the AMQ Streams operator
. Create a new namespace called `knative-serving` and select this as the current project
. Navigate to the _Operators > Installed Operators_ tab and wait until OpenShift Serverless is successfully copied
. Click on the _Knative Serving_ link and then press the _Create Knative Serving_ button
+
image:knative-serving-cr-console.png[]
+
. A default CR YAML UI will appear. Point out some of the more interesting elements of the CR (as well as the help on the right side of the screen)
+
image:knative-cr-interesting.png[]
+
. Click the _CREATE_ button
. Wait for a bit and after a while, a new tab should appear in the left OpenShift drawer navigation, namely the _Serverless tab
. Click on the tab and show what's underneath
+
image:serverless-drawer.png[]


=== Install the initial payment service 

. Run the following commands in a shell
+
----
source scripts/shell-setup.sh
code .
----
+
. From a shell in VSCode, run the following to install the necessary prerequisites (NOTE the `--crc` flag)
+
----
source scripts/shell-setup.sh
$DEMO_HOME/scripts/install-prereq.sh --crc
----
+
. When that completes, then install the payment service
+
----
$DEMO_HOME/scripts/install-payment.sh
----
+
. Next use the crc _Developer Perspective_ and _Topology_ to show what is currently in our project
+
image:developer-payment-alone.png[]
+
.. Explain that the payment service will watch the orders topic and "process that" and put the output on the payments topic
.. Show that there is one instance of the payment service running all the time
.. Show the different kafka nodes
+
. Next demonstrate how the payment service currently interacts with the kafka queues by setting up two windows
+
.. *Terminal Window 2* Run the following command to watch the payments:
+
----
oc exec -c kafka my-cluster-kafka-0 -n user1-cloudnativeapps -- /opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic payments
----
+
.. *Terminal Window 1* Run the following command to simulate an order being placed by the coolstore
+
----
cat $DEMO_HOME/example/order-payload.json | oc exec -i -c kafka my-cluster-kafka-0 -n user1-cloudnativeapps -- /opt/kafka/bin/kafka-console-producer.sh --broker-list localhost:9092 --topic orders
----
+
. You should now see the order being processed as seen here:
+
image:payment-kafka-test.png[]

=== Convert Payment Service to Serverless 

Now lets wrap our payment service in a knative service.  This will allow knative to manage the container and decide when new containers should be started.  In wrapping it in a service, we're expecting it to no longer need to poll the kafka topic.

. First stop our payment service from being run all the time (by deleting a deployment) and remove all connections to it
+
----
oc delete dc/payment route/payment svc/payment
----
+
. Next, let's remove the aspects of the payment resource that causes it to poll the order service.  In vscode, use kbd:[CMD+p] to navigate to the *PaymentResource.java* file 
+
. Delete (or comment out) the onMessage() method:
+
image:onMessage.png[]
+
. And delete the configuration for the incoming stream. In *application.properties* , delete (or comment out) the following lines for the Incoming stream:
+
image:payment-app-properties.png[]
+
** Explain that this is no longer necessary because instead the event will trigger the starting of a container with the event as the incoming context.
+
. Now rebuild the service locally
+
----
cd $DEMO_HOME/payment-service
export MAVEN_OPTS=" -Xmx1024M -Xss128M -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=1024M -XX:+CMSClassUnloadingEnabled"
mvn clean package -DskipTests
----
+
. And remotely (to upload the binary and bake it into a new image).  [blue]#NOTE: This should take about 1.5 minutes with crc cluster#
+
----
oc start-build payment --from-file target/*-runner.jar --follow 
----
+
** When the build is done, notice that there is a new image in the image registry (reached from the _Administrator Perspective_ under _Builds > ImageStreams_):
+
image:payment-latest-image.png[]
+
. Now we want to specially tag this image as not using kafka
+
----
oc tag payment:latest payment:nokafka
----
+
. Next let's create a knative service using the image we just tagged.  We'll name the revision for the service name ({{.Service}} which will resolve to payment) and ({{.Generation}}, which should be 1)
+
[TIP]
.You can use the command line to quickly get the image stream
====
----
oc get is payment -o jsonpath="{.status.dockerImageRepository}" -n user1-cloudnativeapps
----
====
+
----
kn service create payment --image image-registry.openshift-image-registry.svc:5000/user1-cloudnativeapps/payment:nokafka --revision-name "{{.Service}}-{{.Generation}}"

# Which gives the output
Creating service 'payment' in namespace 'user1-cloudnativeapps':

  0.299s The Route is still working to reflect the latest desired specification.
  1.008s Configuration "payment" is waiting for a Revision to become ready.
 68.597s ...
 69.390s Ingress has not yet been reconciled.
 70.223s Ready to serve.

Service 'payment' created to latest revision 'payment-1' is available at URL:
http://payment.user1-cloudnativeapps.apps-crc.testing
----
+
** Show these aspects in the UI
+
image:knative-payment-revisions.png[]
+
** Show that the payment service is at 0 from the _Topology_ of the _Developer Perspective_
+
image:knative-developer.png[]
+
. Demonstrate that the service handling http requests by invoking using the RESTClient extension in vscode.  
.. Make sure *Terminal Window 2* (from above) is still open and watching the payments topic.
.. Use kbd:[CMD+p] and enter `payment.http` to open this file quickly
.. Click the "code-lens" above the first instance to post to the service
+
image:payment-restclient.png[]
+
.. Switch quickly to the _Developer Perspective_ to show the service spinning up
+
image:payment-spin-up.png[]
+
.. Switch back to the shell showing the kafka queue
+
.. Then show it scaling back down to 0


=== Update Payment Service 

. Edit the PaymentResource so that the success output shows some sort of change

. Compile locally with the following command
+
----
cd $DEMO_HOME/payment-service
mvn package -DskipTests
----
+
. When the compilation is done, upload the binary to make a new image ([blue]#NOTE: This should take about 1.5 minutes with crc cluster)#
+
----
oc start-build payment --from-file target/*-runner.jar --follow
----
+
. Then update the service with the newest revision
+
----
kn service update payment --image $(oc get istag/payment:latest -o jsonpath='{.image.dockerImageReference}') --revision-name "{{.Service}}-{{.Generation}}"
----
+
. Demonstrate that there is a new revision that is taking traffic
+
----
$ kn service describe payment
Name:       payment
Namespace:  user1-cloudnativeapps
Age:        4h
URL:        http://payment.user1-cloudnativeapps.apps-crc.testing

Revisions:  
  100%  @latest (payment-5) [5] (29s)
        Image:  image-registry.openshift-image-registry.svc:5000/user1-cloudnativeapps/payment:latest (pinned to 64a5a8)

Conditions:  
  OK TYPE                   AGE REASON
  ++ Ready                  20s 
  ++ ConfigurationsReady    21s 
  ++ RoutesReady            20s 
----
+
** the _pinned to_ field should match the first characters of the sha for the image labelled `:latest`
+
image:find-image.png[]

[TIP]
.To delete a knative service
====
Though knative services are reported from oc get svc and oc get rt, you cannot delete them in this way.  Instead you must delete them based on the distinct (knative) descriptor that they have

Here is a command to delete all services (exposed as routes) that have the name that includes 'payment'
----
oc delete services.serving.knative.dev $(oc get rt --no-headers | grep -i payment | awk '{print $1}')
----
====

[NOTE]
.Alternative Knative service creation (without `kn` client)
====
Knative Services can be created not just using the command line but also by creating resources using yaml

----
oc apply -f payment-service/knative/knative-serving-service.yaml 
----

It will take a while for ingress to be configured for the service.  You can issue this command and you should see the following output:

----
$ watch oc get rt
NAME      URL                                                                           READY   REASON
payment   http://payment.user1-cloudnativeapps.apps.service-mesh-demo.openshifttc.com   True    
----
====

=== Trigger Knative Service with Kafka Event

Now we want to use events the order topic to be our *source* (see also link:https://knative.dev/docs/eventing/samples/kafka/source/index.html[here] for generic example) and use the payment service as our *sink*

[NOTE]
====
First we need to install the Kafka knative event source operator as seen below.  Go to link:demo-setup.adoc[here] for more details

image:kafka-event-operator.png[]
====

. Create an instance of kakfa eventing for our namespace.  To do this call
+
----
$ oc apply -f $DEMO_HOME/install/kafka-eventing/kafka-eventing.yaml 
knativeeventingkafka.eventing.knative.dev/knative-eventing-kafka created

$ oc wait --for=condition=InstallSucceeded KnativeEventingKafka knative-eventing-kafka
----
+
.. When the command completes, the following pods will be able to be seen (with the following command):
+
----
$ watch "oc get pods | grep -i ^kafka"

kafka-ch-controller-57cf94b477-dk9ss          1/1     Running     0          73s
kafka-controller-manager-56d58bb444-dtpkd     1/1     Running     0          81s
kafka-webhook-77b75f7c7f-df7vb                1/1     Running     0          72s
----
+
. Then use the yaml file to bind the kafka event source to the payment service sink (show what's going on first)
+
image:kafka-event-source.png[]
+
----
oc apply -f $DEMO_HOME/payment-service/knative/kafka-event-source.yaml 
----
+
. Check to make source the event source is running
+
----
$ oc get pods -l knative-eventing-source-name=kafka-source
----
+
. Demonstrate event driven serverless
+
.. Make sure the _Developer Perspective_ can be seen
.. Have *Terminal Window 2* up showing what gets written to the payment queue
.. In *Terminal Window 1* run the following command to simulate an order coming in from the order service
+
----
cat $DEMO_HOME/example/order-payload.json | oc exec -i -c kafka my-cluster-kafka-0 -n user1-cloudnativeapps -- /opt/kafka/bin/kafka-console-producer.sh --broker-list localhost:9092 --topic orders
----
+
.. Show that the service gets spun up and show the results of the processing in the payment queue

== Knative payment on full cluster (integration with website) 

=== Install the coolstore project 

WARNING: You will need to log into a real OpenShift cluster to run the coolstore website.  The requirements are too heavy to run it with crc (as of verion 1.8)

. Locally log into the cluster with `oc login` command
. Setup local environment
+
----
source scripts/shell-setup.sh
----
+
. Run the coolstore setup script. NOTE: You can cause cluster side rebuilds of all the components (instead of updating images to point to dockerhub) by using the `--rebuild` flag
+
----
$DEMO_HOME/scripts/install-coolstore.sh -p coolstore
----
+
. It will take a little while for all the pods to be deployed (and images downloaded)
. Test the deployment by getting the route
+
----
echo "http://$(oc get route coolstore-ui -o jsonpath='{.spec.host}')/"
----

[NOTE]
.Where's the payment service?
====
This command does not build the payment service as it's assumed that the it will get changed.  But if you need to create the payment service

----
cd $DEMO_HOME/payment-service
export MAVEN_OPTS="-Xmx1024M -Xss128M -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=1024M -XX:+CMSClassUnloadingEnabled"
mvn clean package -DskipTests
----

When the build is done, deploy with:

----
oc start-build payment --from-file target/*-runner.jar --follow
----

Finally, be sure to tag the payment build (we'll need this for service revisions later)
----
oc tag payment:latest payment:original
----

====

=== Coolstore without payment processing ===

[red]#FIXME: Needs to be finished#

Navigate to the coolstore ui (by using badge on the coolstore-ui component)

Demonstrate that purchases can be made (as before), but orders are now not processed

image:no-payment-processing.png[]

==== Invoke the service ====

You can call the knative service that you just created if it is ready.  Your service is ready if you issue the following command and get the following output
----
$ oc get rt
NAME      URL                                                                           READY   REASON
payment   http://payment.user1-cloudnativeapps.apps.service-mesh-demo.openshifttc.com   True    
----

Create a new tab on the QueueWindow and navigate to the URL found (or use command below to get it quickly)
----
export SVC_URL=$(oc get rt payment -o template='{{ .status.url }}')
----

Notice that the Developer Perspective service springs to life and that the order (eventually) gets processed


==== Context ====
image::coolstore-initial-ui.png[]

== Demonstrate the Working App

Demonstrate the app working.  By going to the store.  You can find the URL like this:
----
oc get route coolstore-ui -n user1-cloudnativeapps
----

[red]#FIXME: This is where we left off on 4-04.  Works up to this point on remote cluster#

[blue]#NOTE: You may find that it takes the page a while to load the first time, and also that the inventory might not show.  If this happens, just press reload#

image:add-to-cart.png[]

From the cart, checkout and then enter credit card details (any 16-digit number beginning with 4 will work)

image:checkout.png[]

Now navigate to the orders page.  Notice that the order gets processed after about 5 seconds (you may need to refresh page to see this)

image:orders.png[]


== Create a Knative service (Knative Serving)

NOTE: You must have done the Knative Operator installation in the link:demo-setup.adoc[Setup doc].

First stop our payment service from being run all the time (by deleting a deployment) and remove all connections to it

----
oc project user1-cloudnativeapps
oc delete dc/payment route/payment svc/payment
----

Next, in order to create the Knative service, we need to know which image needs to be spun up to handle, in this case, order events.  To find the image go to *Builds > Image Streams* on the left menu then input payment to show the payment imagestream. Click on payment imagestream:

image:find-image.png[]

In the Overview tab, copy the IMAGE REPOSITORY value shown 

image:image-repository.png[]

[TIP]
.You can use the command line to quickly get the image stream
====
----
oc get is payment -o jsonpath="{.status.dockerImageRepository}" -n user1-cloudnativeapps
----
====
Then open the *payment-service/knative/knative-serving-service.yaml* file and paste in that value

Then update and update the image: line with this value.

image:knative-service-edit.png[]

[TIP]
.To delete a knative service
====
Though knative services are reported from oc get svc and oc get rt, you cannot delete them in this way.  Instead you must delete them based on the distinct (knative) descriptor that they have

Here is a command to delete all services (exposed as routes) that have the name that includes 'payment'
----
oc delete services.serving.knative.dev $(oc get rt --no-headers | grep -i payment | awk '{print $1}')
----
====

Now create the service using this command:

----
oc apply -f payment-service/knative/knative-serving-service.yaml 
----

[NOTE]
.A better way to install the service
====
If you have access to the kn CLI, you can create a service without YAML.  The nice thing about this is that it will tell you once ingress is configured (without having to run a watch)

----
kn service create payment --image $(oc get istag/payment:initial-build -o jsonpath='{.image.dockerImageReference}') --label "app.kubernetes.io/part-of=focus" --revision-name "{{.Service}}-{{.Generation}}" --annotation sidecar.istio.io/inject=false
----
====

It will take a while for ingress to be configured for the service.  You can issue this command and you should see the following output:

----
$ watch oc get rt
NAME      URL                                                                           READY   REASON
payment   http://payment.user1-cloudnativeapps.apps.service-mesh-demo.openshifttc.com   True    
----

=== Demonstrate that payment is removed

NOTE: The knative serving service will automatically run the pod when created, so best to make sure it goes back to 0 before it goes in the queue

We need to remove our old microservice way of running the payment service.  For that we will delete build configs and existing deployments

Setup your screen like the following.  Notice that QueueWindow is done by going to one of the kafka pods.

image:initial-screen-layout.png[]

Run this command in the queue window
----
bin/kafka-console-consumer.sh --topic orders --bootstrap-server localhost:9092
----

Navigate to the coolstore ui (by using badge on the coolstore-ui component)

Demonstrate that purchases can be made (as before), but orders are now not processed

image:no-payment-processing.png[]

== Invoke the service

You can call the knative service that you just created if it is ready.  Your service is ready if you issue the following command and get the following output
----
$ oc get rt
NAME      URL                                                                           READY   REASON
payment   http://payment.user1-cloudnativeapps.apps.service-mesh-demo.openshifttc.com   True    
----

Create a new tab on the QueueWindow and navigate to the URL found (or use command below to get it quickly)
----
export SVC_URL=$(oc get rt payment -o template='{{ .status.url }}')
----

Notice that the Developer Perspective service springs to life and that the order (eventually) gets processed

== Remove direct Knative integration code

Currently our Payment service directly binds to Kafka to listen for events. Now that we have Knative eventing integration, we no longer need this code. CMD+p to navigate to the *PaymentResource.java* file 

Delete (or comment out) the onMessage() method:

image:onMessage.png[]

And delete the configuration for the incoming stream. In *application.properties* , delete (or comment out) the following lines for the Incoming stream:

image:payment-app-properties.png[]

Explain that this is no longer necessary because instead the event will trigger the starting of a container with the event as the incoming context.

Now rebuild the service locally
----
cd $DEMO_HOME/payment-service
export MAVEN_OPTS=" -Xmx1024M -Xss128M -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=1024M -XX:+CMSClassUnloadingEnabled"
mvn clean package -DskipTests
----

And remotely

----
oc start-build payment --from-file target/*-runner.jar --follow
----

Then tag this new image

----
oc tag payment:latest payment:noqueue
----

And update our revision to use the image we just tagged.  We'll name the revision for the service name ({{.Service}} which will resolve to payment) and ({{.Generation}}, which should be 2)

----
kn service update payment --image $(oc get istag/payment:noqueue -o jsonpath='{.image.dockerImageReference}') --revision-name "{{.Service}}-{{.Generation}}"
----

Demonstrate that there is a new revision that is taking traffic

----
$ kn service describe payment
Name:         payment
Namespace:    user1-cloudnativeapps
Labels:       app.kubernetes.io/part-of=focus
Annotations:  sidecar.istio.io/inject=false
Age:          36m
URL:          http://payment.user1-cloudnativeapps.apps.service-mesh-demo.openshifttc.com
Address:      http://payment.user1-cloudnativeapps.svc.cluster.local

Revisions:  
  100%  @latest (payment-3) [3] (1m)
        Image:  image-registry.openshift-image-registry.svc:5000/user1-cloudnativeapps/payment:noqueue (pinned to 21ca1a)

Conditions:  
  OK TYPE                   AGE REASON
  ++ Ready                   1m 
  ++ ConfigurationsReady     1m 
  ++ RoutesReady             1m 
----

== Create Knative event to kickoff service (Knative Eventing)

Now we want to use events the order topic to be our *source* (see also link:https://knative.dev/docs/eventing/samples/kafka/source/index.html[here] for generic example) and use the payment service as our *sink*

[NOTE]
====
First we need to install the Kafka knative event source operator as seen below.  Go to link:demo-setup.adoc[here] for more details

image:kafka-event-operator.png[]
====

Now we need to create an instance of kakfa eventing for our namespace.  To do this call

----
$ oc apply -f $DEMO_HOME/install/kafka-eventing/kafka-eventing.yaml 
knativeeventingkafka.eventing.knative.dev/knative-eventing-kafka created

$ oc wait --for=condition=InstallSucceeded KnativeEventingKafka knative-eventing-kafka
----

Then wait until all the kafka pods are created.  Use the following watch command and look for output like this

----
$ watch "oc get pods | grep -i ^kafka"

kafka-ch-controller-5f6b47c9fc-7xh8t          0/1     ContainerCreating   0          20m
kafka-ch-dispatcher-5fc59bdf5b-hnt6h          0/1     ContainerCreating   0          20m
kafka-controller-manager-0                    1/1     Running             0          4m25s
kafka-webhook-74d6d5cd-gc4p5                  0/1     ContainerCreating   0          20m
----

Then use the yaml file to bind the kafka event source to the payment service sink (show what's going on first)

image:kafka-event-source.png[]

----
oc apply -f $DEMO_HOME/payment-service/knative/kafka-event-source.yaml 
----

Then check to make source the event source is running

----
$ oc get pods -l knative-eventing-source-name=kafka-source
----

Now we want to prepare some windows for our demo.

*Window 1*: Duplicate the tab where you're looking at the user1-cloudnativeapps project.  Then navigate to the *Workloads > Pods* and find the _my-cluster-kafka-0_ pod.  Go then to the Terminal tab.  From there, enter the command as follows (also in image) and click _Expand_ in the upper right corner

image:watch-orders.png[]

----
bin/kafka-console-consumer.sh --topic orders --bootstrap-server localhost:9092
----

*Window 2*: Duplicate the tab again and then switch to the *Developer Perspective*.  There will be a lot of pods, so you'll want to filter based on the "focus" application group.  Make sure the knative payment pod is featured prominently.  It should indicate zero pods

image:window2-setup.png[]


Then hit the coolstore-ui by *[SHIFT+OPTION] clicking* the launcher icon on the Developer Perspective (see previous) and moving the newly opened window to the right

Recommended arrangement is like this:

image:recommended-layout.png[]

[HINT]
.If you need to open the window another way...
====
You can find the URL by running this command in a terminal
----
oc get route -n user1-cloudnativeapps | grep coolstore-ui | awk '{print $2}'
----
====

Now puchase something and add it to the cart.  Then Checkout.

Upon checkout you should see the payment pod spinning up to consume the order

image:consuming-kafka-queue.png[]

You can then go to the *Orders* section of the site to show that the order was consumed.  When you return, the pod should be spun down (with a clear or black outline).

If you'd like to play more with spin up and spin down, you can click on the route badge on the topography view to show the pod spinning up and then spinning down.

You can also show how subsequent requests when pod is up continue to be serviced by that pod (subject to the max concurrency number setup in knative-eventing).

when this is complete you can either take a look at revisions, or move on to kafka eventing


== Recompile the payment service (quarkus)

[WARNING]
.Resource Requirements for Docker Quarkus Build
====
If you are running linux in a container, you need to make sure the docker daemon has enough memory assigned to it.  This configuration seemed to be enough to build the payment-service

image:docker-requirement.png[]
====

----
cd payment-service
export MAVEN_OPTS=" -Xmx1024M -Xss128M -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=1024M -XX:+CMSClassUnloadingEnabled"
mvn clean package -Pnative -DskipTests
----

While that's compiling, in another VSCode terminal, update our builder to be able to build native quarkus

----
oc delete bc payment
oc new-build quay.io/quarkus/ubi-quarkus-native-binary-s2i:19.2.0 --binary --name=payment -l app=payment
----

Once the native maven build is done, we can start a build using our new configuration

----
cd $DEMO_HOME/payment-service
oc start-build payment --from-file target/*-runner --follow
----

Then tag this latest build accordingly

----
oc tag payment:latest payment:quarkus-native
----

Then update our knative service (tagging revisions before and after updating the service)

----
kn service update payment --tag @latest=traditional
kn service update payment --image $(oc get istag/payment:quarkus-native -o jsonpath='{.image.dockerImageReference}') --revision-name "{{.Service}}-{{.Generation}}"
kn service update payment --tag @latest=native
----

=== Knative Revisions

Start with traffic to the original version

----
$ kn service update payment --traffic traditional=100
Updating Service 'payment' in namespace 'user1-cloudnativeapps':

  0.275s Ingress has not yet been reconciled.
  1.401s Ready to serve.

Service 'payment' updated with latest revision 'payment-4' (unchanged) and URL:
http://payment.user1-cloudnativeapps.apps.cluster-nab-92c5.nab-92c5.example.opentlc.com

export SVC_URL=$(oc get rt payment -o template='{{ .status.url }}')

$ curl $SVC_URL -s -o /dev/null -w "%{time_starttransfer}\n"
12.305205
$ curl $SVC_URL -s -o /dev/null -w "%{time_starttransfer}\n"
0.546286
----

Now look at the quarkus native version

----
$ kn service update payment --traffic native=100
export SVC_URL=$(oc get rt payment -o template='{{ .status.url }}')

$ curl $SVC_URL -s -o /dev/null -w "%{time_starttransfer}\n"f 
10.930526
$ curl $SVC_URL -s -o /dev/null -w "%{time_starttransfer}\n"
0.543870
----

TODO: See link:https://blog.openshift.com/knative-configurations-routes-and-revisions/[here]

TODO: See link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial-basics/0.7.x/02-basic-fundas.html#deploying-new-revision[here]

Tagging in ImageStream
----
oc tag payment@sha256:573f369a858c692b71f02acb470b321816d8ff8ababece8148ac8c939a37c9e2 payment:java
----

=== Service Autoscaling

NOTE: _The knative-serving attribute scale-to-zero-grace-period is a “dynamic parameter” i.e. any updates to this value are reflected immediately to all its consumers; while all other parameters are static parameters i.e. change to it need a restart of the autoscaler deployment of knative-serving namespace._

TODO: See link:https://knative.dev/docs/serving/samples/autoscale-go/index.html[here]
Then reopen the website

==== Service Pinning

TODO: See link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial-basics/0.7.x/02-basic-fundas.html#_service_pinned_to_first_revision[here]

== Troubleshooting ==

=== Insecure ImageRegistry ===

Might be solved as per link:https://github.com/knative/serving/issues/2136[here] but can't get the controller pod to take the new environment variable

Looks like it has something to do with the labels.  If the sha is used instead it seems to work properly.  You can find the sha like this:
----
$ oc get istag/payment:latest -o jsonpath='{.image.dockerImageReference}'
image-registry.openshift-image-registry.svc:5000/user1-cloudnativeapps/payment@sha256:21ca1acc3f292b6e94fab82fe7a9cf7ff743e4a8c9459f711ffad125379cf3c7
----

And then apply it as a service like this:
----
kn service create payment --image $(oc get istag/payment:initial-build -o jsonpath='{.image.dockerImageReference}') --label "app.kubernetes.io/part-of=focus" --revision-name "{{.Service}}-{{.Generation}}" --annotation sidecar.istio.io/inject=false --force
----

----
oc port-forward <image-registry-pod> -n openshift-image-registry 5001:5000
----

To get the cert as a pem file, do this:
----
openssl s_client -showcerts -connect localhost:5001 </dev/null 2>/dev/null|openssl x509 -outform PEM >mycertfile.pem
----

== TODO


* Make sure the reset scripts work appropriately (with the option to keep all operators active)

* test out the image-stream stuff

* update the template to
    - add a variable for the namespace (currently hardcoded to user1-cloudnativeapps)
    - change the image streams
